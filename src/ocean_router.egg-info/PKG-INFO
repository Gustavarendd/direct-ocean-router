Metadata-Version: 2.4
Name: ocean-router
Version: 0.1.0
Summary: Corridor-limited ocean routing pipeline with land avoidance and TSS-aware costs
Author: AutoDev
License: MIT
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Requires-Dist: numpy>=1.26
Requires-Dist: scipy>=1.11
Requires-Dist: shapely>=2.0
Requires-Dist: rasterio>=1.3
Requires-Dist: pyproj>=3.6
Requires-Dist: fiona>=1.9
Requires-Dist: geopandas>=0.14
Requires-Dist: networkx>=3.2
Requires-Dist: pydantic>=2.5
Requires-Dist: fastapi>=0.110
Requires-Dist: uvicorn>=0.23
Requires-Dist: orjson>=3.9
Requires-Dist: typer>=0.9
Requires-Dist: pyyaml>=6.0
Provides-Extra: numba
Requires-Dist: numba>=0.58; extra == "numba"

# Direct Ocean Router

Direct Ocean Router is a corridor-limited voyage planning pipeline that guarantees no land crossings and prefers safe, regulated water. The project is organized to separate offline preprocessing from fast runtime routing.

## Key guarantees

- **No land crossings:** Global routing uses a strict raster mask, then vector validation + local refinement ensures the final polyline never intersects land.
- **Depth safety:** Depth lookups enforce `depth >= draft + safety_margin` with optional near-threshold penalties.
- **Directional lanes:** Traffic Separation Scheme (TSS) lanes are encouraged via direction-aware penalties instead of hard locks.
- **Macro guidance:** A curated passage graph prevents global searches and keeps routing inside known corridors.

## Repository layout

- `configs/` – grid specification, vessel profiles, routing defaults, passage graph, and basin polygons.
- `data/` – raw source data and processed memory-mappable grids (land, bathy, TSS, density, basin index, cached corridors).
- `scripts/` – preprocessing utilities to rasterize and normalize source data into aligned grids.
- `src/ocean_router/` – Python package for grid math, data loaders, routing logic, API, and CLI.

## Quick Start

```bash
# Install in development mode
pip install -e .

# Check current configuration
python -m ocean_router.cli.main info

# Start API server
uvicorn ocean_router.api.main:app --reload
```

## Preprocessing Scripts

Build the routing grids from raw data. All scripts support `--resolution` flag for multi-resolution builds.

### Build All Data (Recommended)

```bash
# Build both 1nm and 0.5nm resolution data
./scripts/build_all_resolutions.sh

# Build only 1nm (default)
./scripts/build_all_resolutions.sh 1nm

# Build only 0.5nm (higher resolution, ~4x larger files)
./scripts/build_all_resolutions.sh 0.5nm

# Build only 0.25nm (very high resolution, ~4x larger than 0.5nm)
./scripts/build_all_resolutions.sh 0.25nm
```

### Individual Scripts

```bash
# Land mask (requires land_polygons.shp from OpenStreetMap)
python scripts/build_land_mask.py \
    --grid configs/grid_1nm.json \
    --resolution 1nm \
    --land data/raw/land_polygons.shp \
    --purpose strict

# Visual land mask (for display only)
python scripts/build_land_mask.py \
    --grid configs/grid_1nm.json \
    --resolution 1nm \
    --land data/raw/land_polygons.shp \
    --purpose visual

# Bathymetry (requires GEBCO GeoTIFF tiles)
python scripts/build_bathy_grid.py \
    --grid configs/grid_1nm.json \
    --resolution 1nm \
    --gebco-dir data/raw/gebco_2025_sub_ice_topo_geotiff

# TSS fields (requires separation_lanes_with_direction.geojson)
python scripts/build_tss_fields.py \
    --grid configs/grid_1nm.json \
    --resolution 1nm \
    --tss-geojson data/raw/separation_lanes_with_direction.geojson

# For 0.5nm resolution, use grid_0.5nm.json (note the dot!)
python scripts/build_tss_fields.py \
    --grid configs/grid_0.5nm.json \
    --resolution 0.5nm \
    --tss-geojson data/raw/separation_lanes_with_direction.geojson

# For 0.25nm resolution, use grid_0.25nm.json
python scripts/build_tss_fields.py \
    --grid configs/grid_0.25nm.json \
    --resolution 0.25nm \
    --tss-geojson data/raw/separation_lanes_with_direction.geojson
```

### Tile rasters (optional, recommended for large grids)

Tile-backed rasters keep routing memory usage low by reading only the tiles needed for each corridor.

```bash
python -m ocean_router.cli.main preprocess tile-rasters \
  --grid configs/grid_1nm.json \
  --land data/processed/land/land_mask_strict_1nm.npy \
  --land-buffered data/processed/land/land_mask_strict_1nm_buffered.npy \
  --bathy data/processed/bathy/depth_1nm.npy \
  --tile-size 2048 \
  --outdir data/processed
```

Tile outputs are written to:

- `data/processed/land_tiles/<resolution>/tile_{tx}_{ty}.npy` + `meta.json`
- `data/processed/bathy_tiles/<resolution>/tile_{tx}_{ty}.npy` + `meta.json`

If tile metadata is present, the router will prefer tiles automatically.

### TSS STRtree indexing

TSS lane centerlines are now indexed at runtime using a Shapely STRtree built directly from the GeoJSON source. This replaces the legacy `tss_lane_graph_*.npz` pipeline; no NPZ lane graphs are required for routing.

## Resolution Switching

The router supports multiple grid resolutions. Switch via environment variable:

```bash
# Use 1nm resolution (default, 21600×10800 cells)
export OCEAN_ROUTER_RESOLUTION=1nm

# Use 0.5nm resolution (43200×21600 cells, ~4x more detail)
export OCEAN_ROUTER_RESOLUTION=0.5nm

# Use 0.25nm resolution (86400×43200 cells, ~4x more detail vs 0.5nm)
export OCEAN_ROUTER_RESOLUTION=0.25nm

# Start server with specific resolution
OCEAN_ROUTER_RESOLUTION=0.5nm uvicorn ocean_router.api.main:app --reload
```

**Note:** You must build the data for a resolution before using it. If requested resolution data doesn't exist, the system falls back to 1nm.

## Data Sizes

| Resolution | Grid Size   | Land Mask | Bathymetry | TSS Fields | Total    |
| ---------- | ----------- | --------- | ---------- | ---------- | -------- |
| 1nm        | 21600×10800 | ~220 MB   | ~445 MB    | ~890 MB    | ~2.7 GB  |
| 0.5nm      | 43200×21600 | ~890 MB   | ~1.8 GB    | ~3.6 GB    | ~10.8 GB |
| 0.25nm     | 86400×43200 | ~3.6 GB   | ~7.2 GB    | ~14.4 GB   | ~43.2 GB |

## Pipeline overview

1. **Preprocess** (offline):
   - Rasterize land polygons to strict (routing) + visual (display) masks and store as `.npy`.
   - Warp bathymetry to the same grid and store as `depth_1nm.npy` (int16 meters with nodata).
   - Rasterize TSS lanes and separation zones; build a direction field from centerlines.
   - (Optional) Tile land/bathy rasters into `land_tiles/` and `bathy_tiles/` for tile-backed loading.
   - Normalize ship-density rasters (optional) to `.npy`.
   - Build basin classifier and passage graph caches.
2. **Runtime** (fast):
   - Load tile-backed rasters for land/depth when available (falling back to memmaps).
   - Classify start/end basins and compute a macro path over `passages.yaml`.
   - Build a buffered corridor mask around macro waypoints.
   - Run corridor-limited A\* with depth checks, TSS penalties, density bias, and turn smoothing.
   - Validate that the resulting polyline never intersects land; refine locally and return GeoJSON.

## Land guard (vector validation + local refinement)

The land guard enforces a hard no-land-crossing guarantee by validating the global route against the original polygons and re-routing locally only where needed.

### Build strict vs visual masks

```bash
# Strict mask (routing): preserves narrow channels, no dilation by default
python scripts/build_land_mask.py --grid configs/grid_1nm.json --resolution 1nm \
  --land data/raw/land_polygons.shp --purpose strict

# Visual mask (display only): all_touched=True, no dilation by default
python scripts/build_land_mask.py --grid configs/grid_1nm.json --resolution 1nm \
  --land data/raw/land_polygons.shp --purpose visual
```

### Configuration knobs

- `corridor_buffer_nm`: local refinement buffer around offending segments (default 25 nm).
- `refine_resolution_nm`: local raster resolution for re-routing (default 0.25 nm).
- `max_refinements`: max local refinement passes before failing (default 5).
- `buffer_growth_factor`: multiplier per retry if refinement fails (default 0.5).
- `tolerance_m`: extra land buffer for conservative validation (default 0).

### Example usage (strict mask + land guard routing)

```python
from pathlib import Path
import json

import numpy as np

from ocean_router.core.grid import GridSpec
from ocean_router.data.bathy import load_bathy
from ocean_router.data.land import LandMask
from ocean_router.routing.astar_fast import CoarseToFineAStar
from ocean_router.routing.costs import CostContext, CostWeights
from ocean_router.land.land_guard import LandGuardParams, build_land_index, route_with_land_guard

grid = GridSpec.from_file("configs/grid_1nm.json")
land_mask = LandMask("data/processed/land/land_mask_strict_1nm.npy")
bathy = load_bathy("data/processed/bathy/depth_1nm.npy")

class GlobalRouter:
    def __init__(self) -> None:
        self.router = CoarseToFineAStar(grid, bathy, land_mask=land_mask)
        self.context = CostContext(bathy=bathy, tss=None, density=None, grid_dx=grid.dx, grid_dy=grid.dy, land=None, grid=grid)
        self.weights = CostWeights()

    def route(self, start, end):
        result = self.router.search(start, end, self.context, self.weights, min_depth=10.0)
        return result.path, {"success": result.success, "cost": result.cost, "explored": result.explored}

def local_router_factory(local_grid, local_land_mask):
    bathy_local = np.full((local_grid.height, local_grid.width), -10000, dtype=np.int16)
    local_router = CoarseToFineAStar(local_grid, bathy_local, land_mask=local_land_mask)
    class LocalBathy:
        def __init__(self, depth):
            self.depth = depth
            self.nodata = -32768
        def is_safe(self, y, x, min_draft):
            return True
        def depth_penalty(self, y, x, min_draft, near_threshold_penalty=0.0):
            return 0.0
    context = CostContext(bathy=LocalBathy(bathy_local), tss=None, density=None,
                          grid_dx=local_grid.dx, grid_dy=local_grid.dy, land=None, grid=local_grid)
    weights = CostWeights()
    class LocalRouter:
        def route(self, start, end):
            result = local_router.search(start, end, context, weights, min_depth=1.0)
            return result.path
    return LocalRouter()

land_index = build_land_index(Path("data/raw/land_polygons.shp"))
params = LandGuardParams(local_router_factory=local_router_factory)

start = (12.0, 55.7)
end = (12.7, 55.7)
route = route_with_land_guard(start, end, GlobalRouter(), land_index, params)

geojson = {"type": "LineString", "coordinates": route}
Path("route.geojson").write_text(json.dumps(geojson))
```

## CLI Commands

```bash
# Show configuration and available data
python -m ocean_router.cli.main info

# Show/set resolution
python -m ocean_router.cli.main resolution         # Show current
python -m ocean_router.cli.main resolution 0.5nm   # Set to 0.5nm
python -m ocean_router.cli.main resolution 0.25nm  # Set to 0.25nm

# Compute a route
python -m ocean_router.cli.main route --start "lat,lon" --end "lat,lon" --draft 9.5 --margin 2.0
```

## Data expectations

Place raw inputs under `data/raw/`:

- `land_polygons.shp` – OSM land polygons (from osmdata.openstreetmap.de)
- `gebco_2025_sub_ice_topo_geotiff/` – GEBCO bathymetry tiles
- `separation_lanes_with_direction.geojson` – TSS lanes with flow bearings

Processed outputs live in `data/processed/` under subfolders for land, bathy, tss, density, basins, and cached corridors.

## Vector TSS routing (hybrid)

The vector TSS layer builds a directed lane graph from seamark centerlines and uses connector edges to splice open-sea routing into the lane network. This avoids ultra-fine global grids while enforcing Rule 10-style behavior (directional lanes, separation zones forbidden, angle-biased crossings).

### Build + cache the TSS vector graph

```bash
pip install -e . && python - <<'PY'
from pathlib import Path
from ocean_router.tss.tss_graph import (
    build_directed_lane_graph,
    filter_ocean_tss_features,
    load_tss_geojson,
)

geojson = Path("data/raw/separation_lanes_with_direction.geojson")
features = filter_ocean_tss_features(load_tss_geojson(geojson))
graph = build_directed_lane_graph(features, sepzone_buffer_nm=0.2)
graph.save(Path("data/processed/tss/tss_vector_graph.pkl"))
print(f"cached edges={len(graph.edges)} zones={len(graph.zones)}")
PY
```

### Configuration knobs (defaults in `TSSGraphConfig`)

- `sepzone_buffer_nm`: buffer width (nm) when separation zones are only linework.
- `connector_radius_nm`: search radius (nm) for lane entry/exit connectors.
- `max_connectors`: maximum connector candidates per endpoint.
- `entry_angle_weight` / `entry_max_angle_deg`: penalty + cutoff for entry/exit angle mismatch.
- `crossing_target_deg` / `crossing_angle_weight` / `crossing_max_angle_deg`: 90° crossing preference + cutoff.
- `crossing_penalty`: multiplier for crossing connectors (discourages crossings unless needed).

### Routing usage

Use `route_with_tss(start, goal, open_sea_router, tss_graph, forbidden, config)` to run a combined A\* search over open-sea + TSS lanes, returning a lane-following polyline when appropriate.

## API Server

```bash
# Start with default 1nm resolution
pip install -e . && uvicorn ocean_router.api.main:app --reload

# Start with 0.5nm resolution
OCEAN_ROUTER_RESOLUTION=0.5nm uvicorn ocean_router.api.main:app --reload

# Start with 0.25nm resolution
OCEAN_ROUTER_RESOLUTION=0.25nm uvicorn ocean_router.api.main:app --reload
```

## create Html visualizations

```bash
# Generate HTML visualization of a route
python scripts/visualize_route_html.py --route-json route.json -o route_map.html
```
